# Generated from Group.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\62")
        buf.write("\u00df\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\3\2\3\2\3\2\5\2$\n\2\3\2\3\2")
        buf.write("\3\2\7\2)\n\2\f\2\16\2,\13\2\3\3\3\3\5\3\60\n\3\3\3\3")
        buf.write("\3\7\3\64\n\3\f\3\16\3\67\13\3\3\4\3\4\3\4\5\4<\n\4\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5F\n\5\3\6\3\6\3\6\3")
        buf.write("\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7T\n\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\7\7\\\n\7\f\7\16\7_\13\7\3\b\3\b\3\b\3")
        buf.write("\b\3\b\3\b\3\b\5\bh\n\b\3\b\3\b\3\b\3\b\3\b\5\bo\n\b\7")
        buf.write("\bq\n\b\f\b\16\bt\13\b\3\b\3\b\3\t\3\t\3\n\3\n\3\n\3\n")
        buf.write("\3\n\5\n\177\n\n\3\13\5\13\u0082\n\13\3\13\3\13\3\13\5")
        buf.write("\13\u0087\n\13\3\13\7\13\u008a\n\13\f\13\16\13\u008d\13")
        buf.write("\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\7\f\u00a1\n\f\f\f\16\f\u00a4\13")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u00ac\n\f\3\r\3\r\3\r\3")
        buf.write("\r\3\r\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3")
        buf.write("\16\3\17\3\17\3\17\3\17\3\17\3\17\7\17\u00c4\n\17\f\17")
        buf.write("\16\17\u00c7\13\17\5\17\u00c9\n\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\20\3\20\3\20\3\20\3\20\7\20\u00d6\n\20\f")
        buf.write("\20\16\20\u00d9\13\20\5\20\u00db\n\20\3\20\3\20\3\20\2")
        buf.write("\3\f\21\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36\2\5\3\2")
        buf.write("\n\f\3\2\b\t\3\2\27\30\2\u00f2\2#\3\2\2\2\4/\3\2\2\2\6")
        buf.write(";\3\2\2\2\bE\3\2\2\2\nG\3\2\2\2\fS\3\2\2\2\16`\3\2\2\2")
        buf.write("\20w\3\2\2\2\22~\3\2\2\2\24\u0081\3\2\2\2\26\u008e\3\2")
        buf.write("\2\2\30\u00ad\3\2\2\2\32\u00b6\3\2\2\2\34\u00bd\3\2\2")
        buf.write("\2\36\u00d0\3\2\2\2 $\5\34\17\2!$\5\4\3\2\"$\7&\2\2# ")
        buf.write("\3\2\2\2#!\3\2\2\2#\"\3\2\2\2$*\3\2\2\2%)\5\34\17\2&)")
        buf.write("\5\4\3\2\')\7&\2\2(%\3\2\2\2(&\3\2\2\2(\'\3\2\2\2),\3")
        buf.write("\2\2\2*(\3\2\2\2*+\3\2\2\2+\3\3\2\2\2,*\3\2\2\2-\60\5")
        buf.write("\b\5\2.\60\5\6\4\2/-\3\2\2\2/.\3\2\2\2\60\65\3\2\2\2\61")
        buf.write("\64\5\b\5\2\62\64\5\6\4\2\63\61\3\2\2\2\63\62\3\2\2\2")
        buf.write("\64\67\3\2\2\2\65\63\3\2\2\2\65\66\3\2\2\2\66\5\3\2\2")
        buf.write("\2\67\65\3\2\2\28<\5\26\f\29<\5\30\r\2:<\5\32\16\2;8\3")
        buf.write("\2\2\2;9\3\2\2\2;:\3\2\2\2<\7\3\2\2\2=>\5\n\6\2>?\7&\2")
        buf.write("\2?F\3\2\2\2@A\5\f\7\2AB\7&\2\2BF\3\2\2\2CF\5\36\20\2")
        buf.write("DF\7&\2\2E=\3\2\2\2E@\3\2\2\2EC\3\2\2\2ED\3\2\2\2F\t\3")
        buf.write("\2\2\2GH\5\20\t\2HI\7-\2\2IJ\5\f\7\2J\13\3\2\2\2KL\b\7")
        buf.write("\1\2LM\7\34\2\2MN\5\f\7\2NO\7\35\2\2OT\3\2\2\2PT\7\4\2")
        buf.write("\2QT\5\36\20\2RT\5\20\t\2SK\3\2\2\2SP\3\2\2\2SQ\3\2\2")
        buf.write("\2SR\3\2\2\2T]\3\2\2\2UV\f\b\2\2VW\t\2\2\2W\\\5\f\7\t")
        buf.write("XY\f\7\2\2YZ\t\3\2\2Z\\\5\f\7\b[U\3\2\2\2[X\3\2\2\2\\")
        buf.write("_\3\2\2\2][\3\2\2\2]^\3\2\2\2^\r\3\2\2\2_]\3\2\2\2`a\5")
        buf.write("\20\t\2ab\7\7\2\2bg\7\"\2\2ch\5\20\t\2dh\7\4\2\2eh\7\5")
        buf.write("\2\2fh\5\36\20\2gc\3\2\2\2gd\3\2\2\2ge\3\2\2\2gf\3\2\2")
        buf.write("\2hr\3\2\2\2in\7\'\2\2jo\5\20\t\2ko\7\4\2\2lo\7\5\2\2")
        buf.write("mo\5\36\20\2nj\3\2\2\2nk\3\2\2\2nl\3\2\2\2nm\3\2\2\2o")
        buf.write("q\3\2\2\2pi\3\2\2\2qt\3\2\2\2rp\3\2\2\2rs\3\2\2\2su\3")
        buf.write("\2\2\2tr\3\2\2\2uv\7#\2\2v\17\3\2\2\2wx\7\3\2\2x\21\3")
        buf.write("\2\2\2yz\5\f\7\2z{\7.\2\2{|\5\f\7\2|\177\3\2\2\2}\177")
        buf.write("\5\20\t\2~y\3\2\2\2~}\3\2\2\2\177\23\3\2\2\2\u0080\u0082")
        buf.write("\7\31\2\2\u0081\u0080\3\2\2\2\u0081\u0082\3\2\2\2\u0082")
        buf.write("\u0083\3\2\2\2\u0083\u008b\5\22\n\2\u0084\u0086\t\4\2")
        buf.write("\2\u0085\u0087\7\31\2\2\u0086\u0085\3\2\2\2\u0086\u0087")
        buf.write("\3\2\2\2\u0087\u0088\3\2\2\2\u0088\u008a\5\22\n\2\u0089")
        buf.write("\u0084\3\2\2\2\u008a\u008d\3\2\2\2\u008b\u0089\3\2\2\2")
        buf.write("\u008b\u008c\3\2\2\2\u008c\25\3\2\2\2\u008d\u008b\3\2")
        buf.write("\2\2\u008e\u008f\7 \2\2\u008f\u0090\7\34\2\2\u0090\u0091")
        buf.write("\5\24\13\2\u0091\u0092\7\35\2\2\u0092\u0093\7\36\2\2\u0093")
        buf.write("\u0094\7\61\2\2\u0094\u0095\5\4\3\2\u0095\u0096\7\62\2")
        buf.write("\2\u0096\u00a2\3\2\2\2\u0097\u0098\7!\2\2\u0098\u0099")
        buf.write("\7\34\2\2\u0099\u009a\5\24\13\2\u009a\u009b\7\35\2\2\u009b")
        buf.write("\u009c\7\36\2\2\u009c\u009d\7\61\2\2\u009d\u009e\5\4\3")
        buf.write("\2\u009e\u009f\7\62\2\2\u009f\u00a1\3\2\2\2\u00a0\u0097")
        buf.write("\3\2\2\2\u00a1\u00a4\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a2")
        buf.write("\u00a3\3\2\2\2\u00a3\u00ab\3\2\2\2\u00a4\u00a2\3\2\2\2")
        buf.write("\u00a5\u00a6\7\37\2\2\u00a6\u00a7\7\36\2\2\u00a7\u00a8")
        buf.write("\7\61\2\2\u00a8\u00a9\5\4\3\2\u00a9\u00aa\7\62\2\2\u00aa")
        buf.write("\u00ac\3\2\2\2\u00ab\u00a5\3\2\2\2\u00ab\u00ac\3\2\2\2")
        buf.write("\u00ac\27\3\2\2\2\u00ad\u00ae\7(\2\2\u00ae\u00af\5\20")
        buf.write("\t\2\u00af\u00b0\7)\2\2\u00b0\u00b1\5\16\b\2\u00b1\u00b2")
        buf.write("\7\36\2\2\u00b2\u00b3\7\61\2\2\u00b3\u00b4\5\4\3\2\u00b4")
        buf.write("\u00b5\7\62\2\2\u00b5\31\3\2\2\2\u00b6\u00b7\7*\2\2\u00b7")
        buf.write("\u00b8\5\24\13\2\u00b8\u00b9\7\36\2\2\u00b9\u00ba\7\61")
        buf.write("\2\2\u00ba\u00bb\5\4\3\2\u00bb\u00bc\7\62\2\2\u00bc\33")
        buf.write("\3\2\2\2\u00bd\u00be\7+\2\2\u00be\u00bf\5\20\t\2\u00bf")
        buf.write("\u00c8\7\34\2\2\u00c0\u00c5\5\n\6\2\u00c1\u00c2\7\'\2")
        buf.write("\2\u00c2\u00c4\5\n\6\2\u00c3\u00c1\3\2\2\2\u00c4\u00c7")
        buf.write("\3\2\2\2\u00c5\u00c3\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6")
        buf.write("\u00c9\3\2\2\2\u00c7\u00c5\3\2\2\2\u00c8\u00c0\3\2\2\2")
        buf.write("\u00c8\u00c9\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca\u00cb\7")
        buf.write("\35\2\2\u00cb\u00cc\7\36\2\2\u00cc\u00cd\7\61\2\2\u00cd")
        buf.write("\u00ce\5\4\3\2\u00ce\u00cf\7\62\2\2\u00cf\35\3\2\2\2\u00d0")
        buf.write("\u00d1\5\20\t\2\u00d1\u00da\7\34\2\2\u00d2\u00d7\5\n\6")
        buf.write("\2\u00d3\u00d4\7\'\2\2\u00d4\u00d6\5\n\6\2\u00d5\u00d3")
        buf.write("\3\2\2\2\u00d6\u00d9\3\2\2\2\u00d7\u00d5\3\2\2\2\u00d7")
        buf.write("\u00d8\3\2\2\2\u00d8\u00db\3\2\2\2\u00d9\u00d7\3\2\2\2")
        buf.write("\u00da\u00d2\3\2\2\2\u00da\u00db\3\2\2\2\u00db\u00dc\3")
        buf.write("\2\2\2\u00dc\u00dd\7\35\2\2\u00dd\37\3\2\2\2\32#(*/\63")
        buf.write("\65;ES[]gnr~\u0081\u0086\u008b\u00a2\u00ab\u00c5\u00c8")
        buf.write("\u00d7\u00da")
        return buf.getvalue()


class GroupParser ( Parser ):

    grammarFileName = "Group.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'='", "'+'", "'-'", "'*'", "'/'", "'%'", 
                     "'+='", "'-='", "'*='", "'/='", "'<'", "'>'", "'<='", 
                     "'>='", "'!='", "'=='", "'and'", "'or'", "'not'", "'True'", 
                     "'False'", "'('", "')'", "':'", "'else'", "'if'", "'elif'", 
                     "'['", "']'", "'break'", "'continue'", "'\n'", "','", 
                     "'for'", "'in'", "'while'", "'def'" ]

    symbolicNames = [ "<INVALID>", "ID", "INTEGER", "STRING", "BOOL", "ASSIGN", 
                      "ADD", "MINUS", "MULTIPLY", "DIVIDE", "MOD", "ADD_ASSIGN", 
                      "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "LESS", 
                      "GREATER", "EQLESS", "EQGREATER", "NOTEQ", "EQ", "AND", 
                      "OR", "NOT", "TRUE", "FALSE", "OPENPAR", "CLOSEPAR", 
                      "COLON", "ELSE", "IF", "ELIF", "OPENBRACKET", "CLOSEBRACKET", 
                      "BREAK", "CONTINUE", "NEWLINE", "COMMA", "FOR", "IN", 
                      "WHILE", "DEF", "LOOPCONTROL", "ASSIGNS", "CONDITIONAL", 
                      "COMMENTS", "WHITESPACE", "INDENT", "DEDENT" ]

    RULE_python_file = 0
    RULE_multi_input = 1
    RULE_multiLine_input = 2
    RULE_single_input = 3
    RULE_assignment_expr = 4
    RULE_mathmatical_expr = 5
    RULE_list_expr = 6
    RULE_variable_expr = 7
    RULE_conditional_expr = 8
    RULE_star_conditional_expr = 9
    RULE_if_expr = 10
    RULE_for_expr = 11
    RULE_while_expr = 12
    RULE_function_def_expr = 13
    RULE_function_call_expr = 14

    ruleNames =  [ "python_file", "multi_input", "multiLine_input", "single_input", 
                   "assignment_expr", "mathmatical_expr", "list_expr", "variable_expr", 
                   "conditional_expr", "star_conditional_expr", "if_expr", 
                   "for_expr", "while_expr", "function_def_expr", "function_call_expr" ]

    EOF = Token.EOF
    ID=1
    INTEGER=2
    STRING=3
    BOOL=4
    ASSIGN=5
    ADD=6
    MINUS=7
    MULTIPLY=8
    DIVIDE=9
    MOD=10
    ADD_ASSIGN=11
    SUB_ASSIGN=12
    MUL_ASSIGN=13
    DIV_ASSIGN=14
    LESS=15
    GREATER=16
    EQLESS=17
    EQGREATER=18
    NOTEQ=19
    EQ=20
    AND=21
    OR=22
    NOT=23
    TRUE=24
    FALSE=25
    OPENPAR=26
    CLOSEPAR=27
    COLON=28
    ELSE=29
    IF=30
    ELIF=31
    OPENBRACKET=32
    CLOSEBRACKET=33
    BREAK=34
    CONTINUE=35
    NEWLINE=36
    COMMA=37
    FOR=38
    IN=39
    WHILE=40
    DEF=41
    LOOPCONTROL=42
    ASSIGNS=43
    CONDITIONAL=44
    COMMENTS=45
    WHITESPACE=46
    INDENT=47
    DEDENT=48

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Python_fileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_def_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Function_def_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Function_def_exprContext,i)


        def multi_input(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Multi_inputContext)
            else:
                return self.getTypedRuleContext(GroupParser.Multi_inputContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.NEWLINE)
            else:
                return self.getToken(GroupParser.NEWLINE, i)

        def getRuleIndex(self):
            return GroupParser.RULE_python_file

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPython_file" ):
                listener.enterPython_file(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPython_file" ):
                listener.exitPython_file(self)




    def python_file(self):

        localctx = GroupParser.Python_fileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_python_file)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 30
                self.function_def_expr()
                pass

            elif la_ == 2:
                self.state = 31
                self.multi_input()
                pass

            elif la_ == 3:
                self.state = 32
                self.match(GroupParser.NEWLINE)
                pass


            self.state = 40
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GroupParser.ID) | (1 << GroupParser.INTEGER) | (1 << GroupParser.OPENPAR) | (1 << GroupParser.IF) | (1 << GroupParser.NEWLINE) | (1 << GroupParser.FOR) | (1 << GroupParser.WHILE) | (1 << GroupParser.DEF))) != 0):
                self.state = 38
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                if la_ == 1:
                    self.state = 35
                    self.function_def_expr()
                    pass

                elif la_ == 2:
                    self.state = 36
                    self.multi_input()
                    pass

                elif la_ == 3:
                    self.state = 37
                    self.match(GroupParser.NEWLINE)
                    pass


                self.state = 42
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Multi_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_input(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Single_inputContext)
            else:
                return self.getTypedRuleContext(GroupParser.Single_inputContext,i)


        def multiLine_input(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.MultiLine_inputContext)
            else:
                return self.getTypedRuleContext(GroupParser.MultiLine_inputContext,i)


        def getRuleIndex(self):
            return GroupParser.RULE_multi_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_input" ):
                listener.enterMulti_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_input" ):
                listener.exitMulti_input(self)




    def multi_input(self):

        localctx = GroupParser.Multi_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_multi_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GroupParser.ID, GroupParser.INTEGER, GroupParser.OPENPAR, GroupParser.NEWLINE]:
                self.state = 43
                self.single_input()
                pass
            elif token in [GroupParser.IF, GroupParser.FOR, GroupParser.WHILE]:
                self.state = 44
                self.multiLine_input()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 51
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 49
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GroupParser.ID, GroupParser.INTEGER, GroupParser.OPENPAR, GroupParser.NEWLINE]:
                        self.state = 47
                        self.single_input()
                        pass
                    elif token in [GroupParser.IF, GroupParser.FOR, GroupParser.WHILE]:
                        self.state = 48
                        self.multiLine_input()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 53
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiLine_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def if_expr(self):
            return self.getTypedRuleContext(GroupParser.If_exprContext,0)


        def for_expr(self):
            return self.getTypedRuleContext(GroupParser.For_exprContext,0)


        def while_expr(self):
            return self.getTypedRuleContext(GroupParser.While_exprContext,0)


        def getRuleIndex(self):
            return GroupParser.RULE_multiLine_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiLine_input" ):
                listener.enterMultiLine_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiLine_input" ):
                listener.exitMultiLine_input(self)




    def multiLine_input(self):

        localctx = GroupParser.MultiLine_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_multiLine_input)
        try:
            self.state = 57
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GroupParser.IF]:
                self.enterOuterAlt(localctx, 1)
                self.state = 54
                self.if_expr()
                pass
            elif token in [GroupParser.FOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 55
                self.for_expr()
                pass
            elif token in [GroupParser.WHILE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 56
                self.while_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Single_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment_expr(self):
            return self.getTypedRuleContext(GroupParser.Assignment_exprContext,0)


        def NEWLINE(self):
            return self.getToken(GroupParser.NEWLINE, 0)

        def mathmatical_expr(self):
            return self.getTypedRuleContext(GroupParser.Mathmatical_exprContext,0)


        def function_call_expr(self):
            return self.getTypedRuleContext(GroupParser.Function_call_exprContext,0)


        def getRuleIndex(self):
            return GroupParser.RULE_single_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingle_input" ):
                listener.enterSingle_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingle_input" ):
                listener.exitSingle_input(self)




    def single_input(self):

        localctx = GroupParser.Single_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_single_input)
        try:
            self.state = 67
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 59
                self.assignment_expr()
                self.state = 60
                self.match(GroupParser.NEWLINE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 62
                self.mathmatical_expr(0)
                self.state = 63
                self.match(GroupParser.NEWLINE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 65
                self.function_call_expr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 66
                self.match(GroupParser.NEWLINE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assignment_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # Variable_exprContext
            self.op = None # Token
            self.right = None # Mathmatical_exprContext

        def variable_expr(self):
            return self.getTypedRuleContext(GroupParser.Variable_exprContext,0)


        def ASSIGNS(self):
            return self.getToken(GroupParser.ASSIGNS, 0)

        def mathmatical_expr(self):
            return self.getTypedRuleContext(GroupParser.Mathmatical_exprContext,0)


        def getRuleIndex(self):
            return GroupParser.RULE_assignment_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment_expr" ):
                listener.enterAssignment_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment_expr" ):
                listener.exitAssignment_expr(self)




    def assignment_expr(self):

        localctx = GroupParser.Assignment_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_assignment_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            localctx.left = self.variable_expr()
            self.state = 70
            localctx.op = self.match(GroupParser.ASSIGNS)
            self.state = 71
            localctx.right = self.mathmatical_expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mathmatical_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # Mathmatical_exprContext
            self.op = None # Token
            self.right = None # Mathmatical_exprContext

        def OPENPAR(self):
            return self.getToken(GroupParser.OPENPAR, 0)

        def mathmatical_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Mathmatical_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Mathmatical_exprContext,i)


        def CLOSEPAR(self):
            return self.getToken(GroupParser.CLOSEPAR, 0)

        def INTEGER(self):
            return self.getToken(GroupParser.INTEGER, 0)

        def function_call_expr(self):
            return self.getTypedRuleContext(GroupParser.Function_call_exprContext,0)


        def variable_expr(self):
            return self.getTypedRuleContext(GroupParser.Variable_exprContext,0)


        def MULTIPLY(self):
            return self.getToken(GroupParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(GroupParser.DIVIDE, 0)

        def MOD(self):
            return self.getToken(GroupParser.MOD, 0)

        def ADD(self):
            return self.getToken(GroupParser.ADD, 0)

        def MINUS(self):
            return self.getToken(GroupParser.MINUS, 0)

        def getRuleIndex(self):
            return GroupParser.RULE_mathmatical_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMathmatical_expr" ):
                listener.enterMathmatical_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMathmatical_expr" ):
                listener.exitMathmatical_expr(self)



    def mathmatical_expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GroupParser.Mathmatical_exprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_mathmatical_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 74
                self.match(GroupParser.OPENPAR)
                self.state = 75
                self.mathmatical_expr(0)
                self.state = 76
                self.match(GroupParser.CLOSEPAR)
                pass

            elif la_ == 2:
                self.state = 78
                self.match(GroupParser.INTEGER)
                pass

            elif la_ == 3:
                self.state = 79
                self.function_call_expr()
                pass

            elif la_ == 4:
                self.state = 80
                self.variable_expr()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 91
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 89
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
                    if la_ == 1:
                        localctx = GroupParser.Mathmatical_exprContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mathmatical_expr)
                        self.state = 83
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 84
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GroupParser.MULTIPLY) | (1 << GroupParser.DIVIDE) | (1 << GroupParser.MOD))) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 85
                        localctx.right = self.mathmatical_expr(7)
                        pass

                    elif la_ == 2:
                        localctx = GroupParser.Mathmatical_exprContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_mathmatical_expr)
                        self.state = 86
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 87
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==GroupParser.ADD or _la==GroupParser.MINUS):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 88
                        localctx.right = self.mathmatical_expr(6)
                        pass

             
                self.state = 93
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class List_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Variable_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Variable_exprContext,i)


        def ASSIGN(self):
            return self.getToken(GroupParser.ASSIGN, 0)

        def OPENBRACKET(self):
            return self.getToken(GroupParser.OPENBRACKET, 0)

        def CLOSEBRACKET(self):
            return self.getToken(GroupParser.CLOSEBRACKET, 0)

        def INTEGER(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.INTEGER)
            else:
                return self.getToken(GroupParser.INTEGER, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.STRING)
            else:
                return self.getToken(GroupParser.STRING, i)

        def function_call_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Function_call_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Function_call_exprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.COMMA)
            else:
                return self.getToken(GroupParser.COMMA, i)

        def getRuleIndex(self):
            return GroupParser.RULE_list_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_expr" ):
                listener.enterList_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_expr" ):
                listener.exitList_expr(self)




    def list_expr(self):

        localctx = GroupParser.List_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_list_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.variable_expr()
            self.state = 95
            self.match(GroupParser.ASSIGN)
            self.state = 96
            self.match(GroupParser.OPENBRACKET)
            self.state = 101
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 97
                self.variable_expr()
                pass

            elif la_ == 2:
                self.state = 98
                self.match(GroupParser.INTEGER)
                pass

            elif la_ == 3:
                self.state = 99
                self.match(GroupParser.STRING)
                pass

            elif la_ == 4:
                self.state = 100
                self.function_call_expr()
                pass


            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GroupParser.COMMA:
                self.state = 103
                self.match(GroupParser.COMMA)

                self.state = 108
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                if la_ == 1:
                    self.state = 104
                    self.variable_expr()
                    pass

                elif la_ == 2:
                    self.state = 105
                    self.match(GroupParser.INTEGER)
                    pass

                elif la_ == 3:
                    self.state = 106
                    self.match(GroupParser.STRING)
                    pass

                elif la_ == 4:
                    self.state = 107
                    self.function_call_expr()
                    pass


                self.state = 114
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 115
            self.match(GroupParser.CLOSEBRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(GroupParser.ID, 0)

        def getRuleIndex(self):
            return GroupParser.RULE_variable_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_expr" ):
                listener.enterVariable_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_expr" ):
                listener.exitVariable_expr(self)




    def variable_expr(self):

        localctx = GroupParser.Variable_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_variable_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(GroupParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conditional_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mathmatical_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Mathmatical_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Mathmatical_exprContext,i)


        def CONDITIONAL(self):
            return self.getToken(GroupParser.CONDITIONAL, 0)

        def variable_expr(self):
            return self.getTypedRuleContext(GroupParser.Variable_exprContext,0)


        def getRuleIndex(self):
            return GroupParser.RULE_conditional_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_expr" ):
                listener.enterConditional_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_expr" ):
                listener.exitConditional_expr(self)




    def conditional_expr(self):

        localctx = GroupParser.Conditional_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_conditional_expr)
        try:
            self.state = 124
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 119
                self.mathmatical_expr(0)
                self.state = 120
                self.match(GroupParser.CONDITIONAL)
                self.state = 121
                self.mathmatical_expr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 123
                self.variable_expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Star_conditional_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Conditional_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Conditional_exprContext,i)


        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.NOT)
            else:
                return self.getToken(GroupParser.NOT, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.AND)
            else:
                return self.getToken(GroupParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.OR)
            else:
                return self.getToken(GroupParser.OR, i)

        def getRuleIndex(self):
            return GroupParser.RULE_star_conditional_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStar_conditional_expr" ):
                listener.enterStar_conditional_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStar_conditional_expr" ):
                listener.exitStar_conditional_expr(self)




    def star_conditional_expr(self):

        localctx = GroupParser.Star_conditional_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_star_conditional_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GroupParser.NOT:
                self.state = 126
                self.match(GroupParser.NOT)


            self.state = 129
            self.conditional_expr()
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GroupParser.AND or _la==GroupParser.OR:
                self.state = 130
                _la = self._input.LA(1)
                if not(_la==GroupParser.AND or _la==GroupParser.OR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 132
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GroupParser.NOT:
                    self.state = 131
                    self.match(GroupParser.NOT)


                self.state = 134
                self.conditional_expr()
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(GroupParser.IF, 0)

        def OPENPAR(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.OPENPAR)
            else:
                return self.getToken(GroupParser.OPENPAR, i)

        def star_conditional_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Star_conditional_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Star_conditional_exprContext,i)


        def CLOSEPAR(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.CLOSEPAR)
            else:
                return self.getToken(GroupParser.CLOSEPAR, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.COLON)
            else:
                return self.getToken(GroupParser.COLON, i)

        def INDENT(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.INDENT)
            else:
                return self.getToken(GroupParser.INDENT, i)

        def multi_input(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Multi_inputContext)
            else:
                return self.getTypedRuleContext(GroupParser.Multi_inputContext,i)


        def DEDENT(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.DEDENT)
            else:
                return self.getToken(GroupParser.DEDENT, i)

        def ELIF(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.ELIF)
            else:
                return self.getToken(GroupParser.ELIF, i)

        def ELSE(self):
            return self.getToken(GroupParser.ELSE, 0)

        def getRuleIndex(self):
            return GroupParser.RULE_if_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_expr" ):
                listener.enterIf_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_expr" ):
                listener.exitIf_expr(self)




    def if_expr(self):

        localctx = GroupParser.If_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_if_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(GroupParser.IF)
            self.state = 141
            self.match(GroupParser.OPENPAR)
            self.state = 142
            self.star_conditional_expr()
            self.state = 143
            self.match(GroupParser.CLOSEPAR)
            self.state = 144
            self.match(GroupParser.COLON)

            self.state = 145
            self.match(GroupParser.INDENT)
            self.state = 146
            self.multi_input()
            self.state = 147
            self.match(GroupParser.DEDENT)
            self.state = 160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GroupParser.ELIF:
                self.state = 149
                self.match(GroupParser.ELIF)
                self.state = 150
                self.match(GroupParser.OPENPAR)
                self.state = 151
                self.star_conditional_expr()
                self.state = 152
                self.match(GroupParser.CLOSEPAR)
                self.state = 153
                self.match(GroupParser.COLON)
                self.state = 154
                self.match(GroupParser.INDENT)
                self.state = 155
                self.multi_input()
                self.state = 156
                self.match(GroupParser.DEDENT)
                self.state = 162
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GroupParser.ELSE:
                self.state = 163
                self.match(GroupParser.ELSE)
                self.state = 164
                self.match(GroupParser.COLON)
                self.state = 165
                self.match(GroupParser.INDENT)
                self.state = 166
                self.multi_input()
                self.state = 167
                self.match(GroupParser.DEDENT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(GroupParser.FOR, 0)

        def variable_expr(self):
            return self.getTypedRuleContext(GroupParser.Variable_exprContext,0)


        def IN(self):
            return self.getToken(GroupParser.IN, 0)

        def list_expr(self):
            return self.getTypedRuleContext(GroupParser.List_exprContext,0)


        def COLON(self):
            return self.getToken(GroupParser.COLON, 0)

        def INDENT(self):
            return self.getToken(GroupParser.INDENT, 0)

        def multi_input(self):
            return self.getTypedRuleContext(GroupParser.Multi_inputContext,0)


        def DEDENT(self):
            return self.getToken(GroupParser.DEDENT, 0)

        def getRuleIndex(self):
            return GroupParser.RULE_for_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_expr" ):
                listener.enterFor_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_expr" ):
                listener.exitFor_expr(self)




    def for_expr(self):

        localctx = GroupParser.For_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_for_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            self.match(GroupParser.FOR)
            self.state = 172
            self.variable_expr()
            self.state = 173
            self.match(GroupParser.IN)
            self.state = 174
            self.list_expr()
            self.state = 175
            self.match(GroupParser.COLON)

            self.state = 176
            self.match(GroupParser.INDENT)
            self.state = 177
            self.multi_input()
            self.state = 178
            self.match(GroupParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class While_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(GroupParser.WHILE, 0)

        def star_conditional_expr(self):
            return self.getTypedRuleContext(GroupParser.Star_conditional_exprContext,0)


        def COLON(self):
            return self.getToken(GroupParser.COLON, 0)

        def INDENT(self):
            return self.getToken(GroupParser.INDENT, 0)

        def multi_input(self):
            return self.getTypedRuleContext(GroupParser.Multi_inputContext,0)


        def DEDENT(self):
            return self.getToken(GroupParser.DEDENT, 0)

        def getRuleIndex(self):
            return GroupParser.RULE_while_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhile_expr" ):
                listener.enterWhile_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhile_expr" ):
                listener.exitWhile_expr(self)




    def while_expr(self):

        localctx = GroupParser.While_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_while_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(GroupParser.WHILE)
            self.state = 181
            self.star_conditional_expr()
            self.state = 182
            self.match(GroupParser.COLON)

            self.state = 183
            self.match(GroupParser.INDENT)
            self.state = 184
            self.multi_input()
            self.state = 185
            self.match(GroupParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_def_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEF(self):
            return self.getToken(GroupParser.DEF, 0)

        def variable_expr(self):
            return self.getTypedRuleContext(GroupParser.Variable_exprContext,0)


        def OPENPAR(self):
            return self.getToken(GroupParser.OPENPAR, 0)

        def CLOSEPAR(self):
            return self.getToken(GroupParser.CLOSEPAR, 0)

        def COLON(self):
            return self.getToken(GroupParser.COLON, 0)

        def INDENT(self):
            return self.getToken(GroupParser.INDENT, 0)

        def multi_input(self):
            return self.getTypedRuleContext(GroupParser.Multi_inputContext,0)


        def DEDENT(self):
            return self.getToken(GroupParser.DEDENT, 0)

        def assignment_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Assignment_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Assignment_exprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.COMMA)
            else:
                return self.getToken(GroupParser.COMMA, i)

        def getRuleIndex(self):
            return GroupParser.RULE_function_def_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_def_expr" ):
                listener.enterFunction_def_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_def_expr" ):
                listener.exitFunction_def_expr(self)




    def function_def_expr(self):

        localctx = GroupParser.Function_def_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_function_def_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.match(GroupParser.DEF)
            self.state = 188
            self.variable_expr()
            self.state = 189
            self.match(GroupParser.OPENPAR)
            self.state = 198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GroupParser.ID:
                self.state = 190
                self.assignment_expr()
                self.state = 195
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GroupParser.COMMA:
                    self.state = 191
                    self.match(GroupParser.COMMA)
                    self.state = 192
                    self.assignment_expr()
                    self.state = 197
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 200
            self.match(GroupParser.CLOSEPAR)
            self.state = 201
            self.match(GroupParser.COLON)

            self.state = 202
            self.match(GroupParser.INDENT)
            self.state = 203
            self.multi_input()
            self.state = 204
            self.match(GroupParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_call_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_expr(self):
            return self.getTypedRuleContext(GroupParser.Variable_exprContext,0)


        def OPENPAR(self):
            return self.getToken(GroupParser.OPENPAR, 0)

        def CLOSEPAR(self):
            return self.getToken(GroupParser.CLOSEPAR, 0)

        def assignment_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GroupParser.Assignment_exprContext)
            else:
                return self.getTypedRuleContext(GroupParser.Assignment_exprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GroupParser.COMMA)
            else:
                return self.getToken(GroupParser.COMMA, i)

        def getRuleIndex(self):
            return GroupParser.RULE_function_call_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_call_expr" ):
                listener.enterFunction_call_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_call_expr" ):
                listener.exitFunction_call_expr(self)




    def function_call_expr(self):

        localctx = GroupParser.Function_call_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_function_call_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.variable_expr()
            self.state = 207
            self.match(GroupParser.OPENPAR)
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GroupParser.ID:
                self.state = 208
                self.assignment_expr()
                self.state = 213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GroupParser.COMMA:
                    self.state = 209
                    self.match(GroupParser.COMMA)
                    self.state = 210
                    self.assignment_expr()
                    self.state = 215
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 218
            self.match(GroupParser.CLOSEPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[5] = self.mathmatical_expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def mathmatical_expr_sempred(self, localctx:Mathmatical_exprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 5)
         




